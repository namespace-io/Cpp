### 什么是C++对象模型
+ 语言中直接支持面向对象设计的部分（语言特性，如构造函数，多态，虚函数等）
+ 各种支持的底层实现机制（编译器底层实现，如以虚指针，虚函数表实现多态等）


### 关于对象
C++在布局及存取时间上的额外负担主要是有virtual引起的，包括
+ 虚函数机制virtual function用以支持“执行期绑定”
+ 虚基类机制virtual base class用以实现多次在继承体系中出现的base class
  
两种(静态，非静态)数据成员，三种成员函数(静态，非静态，虚)
### 简单对象模型
按照声明的顺序，所有的数据成员与成员函数的指针存在槽(slot)中, 槽内放指针的原因时避免“member有不同类型而需要不同存储空间”，
容易算出对象的大小，牺牲了执行时间(寻址)和空间(额外指针)，没有被应用与实际产品上

### 表格驱动对象模型
分离数据成员和成员函数，分别放在数据成员表和成员函数表中
对象里面就只放两个表的地址，成员函数表观点称以后为支持虚函数的一个有效方案

### C++对象模型
从简单对象模型中派生而来，并对内存空间和存取时间做了优化  
其中非静态数据成员被放在对象模型中，静态数据成员，静态成员函数和非静态成员函数放在对象之外  
对于虚函数，每个类产生一个表用于存放声明的虚函数的地址，这个表被称为虚表virtual table(vtbl)  
每个类对象中包含一个只想虚表的指针称为vptr, vptr的设定和重置都由类的构造函数，析构函数和拷贝赋值运算自动完成

缺点：如果类对象的非静态数据成员改动(如增加，移除)，那么程序代码需要重新编译，但上述的双表格就提供了较大的弹性

当子类有虚函数或基类有虚函数时，编译器将在对象的第一个位置添加一个虚表指针vptr，为了保证在多重继承能以最高效率取到虚函数表


### 继承
具体实现不同的编译器不同
#### 单一继承

+ 简单模型：子类在末尾增加一个槽slot指向基类实例
+ 表格驱动模型：可以为子类增加第三个指针，用以指向基类表
+ C++对象模型
一般是
```
    // 测试代码: TestSingleDerive.cpp
    vptr----------------------->base virutal f
    base member                 derive virutal g(overwrite base function g)
    derive member               derive virutal h
```
#### 多重继承，虚继承
具体实现不同  
[我的LeetCode PlayGround](https://leetcode.com/playground/koKR4Etn)

### 参考
+ [图说C++对象模型：对象内存布局详解](http://www.cnblogs.com/QG-whz/p/4909359.html#_label4_0)
+ [深入探索C++对象模型](https://github.com/zfengzhen/Blog/blob/master/article/%E3%80%8A%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2C%2B%2B%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.md)