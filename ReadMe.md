> What You Must Know In C++

### C++程序内存分配

+ 栈：由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量,函数参数等,效率高但容量有限  
+ 堆：malloc/free，如果没有free，程序结束后，操作系统会自动回收  
+ 自由存储区：new/delete
+ 全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区。
+ 常量存储区：这是一块比较特殊的存储区，他们里面存放的是常量
```c++
int a = 0; //全局初始化区
char *p1; //全局未初始化区
int main()
{
    int b; //栈
    char s[] = "abc"; //栈
    char *p2; //栈
    char *p3 = "123456"; //123456\0在常量区，p3在栈上
    static int c = 0; //全局（静态）初始化区
    p1 = (char *)malloc(10); //分配得来得10字节的区域在堆区
    p2 = (char *)malloc(20); //分配得来得20字节的区域在堆区
    strcpy(p1, "123456");
    //123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一块
    return 0;
}
```
自由存储区是c++概念，堆是操作系统概念，通常new是通过malloc实现的  
[C++ 自由存储区是否等价于堆](https://www.cnblogs.com/QG-whz/p/5060894.html)

### C++的static关键字的作用
+ 静态全局变量：在全局存储区分配内存，未经初始化会被自动初始化为0， 在声明它的文件中全局可见，在其他文件不可见
+ 静态局部变量：在全局存储区分配内存，在函数执行到该变量声明处的首次被初始化，之后不再初始化，如果没有初始化，自动初始化为0
+ 静态函数：静态函数不能被其他文件所用，只能在声明它的文件中可见
+ 静态成员：属于类的所有对象共享，存储在全局数据区，静态数据成员定义时要分配空间，所以不能在类声明中定义  
**同全局变量相比，使用静态数据成员有两个优势：**
    - 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性 
    - 可以实现信息隐藏，静态数据成员可以是private成员，而全局变量不能
+ 静态成员函数：不与任何对象绑定，不包含this指针，在类的外部定义时不能使用static关键字，该关键字只出现在类内部声明语句中，静态成员函数不能够使用const修饰

### 宏，内联函数和普通函数区别
+ 宏：函数调用要有一定的时间和空间方面的开销，而宏只是在预处理的地方把代码展开，不需要额外的空间和时间方面的开销，所以调用宏比调用函数更有效率
    - 由预处理器对宏进行替代
    - 不能访问对象的私有成员
    - 定义很容易产生二义性
  ```c++
    #define MUL(x) (x) * (x)
    int a = 4;
    MUL(a++) // 20 
  ``` 
+ 内联函数：在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数  
  内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），内联函数在运行时可调试，而宏定义不可以  
  内联函数相比普通函数来说，取消了函数的参数压栈，减少了调用的开销  
  是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器，如果内联函数的函数体过大,一般的编译器会放弃内联方式,而采用普通方式调用函数   
  [虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联](https://www.yuque.com/huihut/interview/readme#ikirca)

### STL中迭代器失效
+ vector
  + 删除操作使得迭代器失效
  + push_back导致扩容使得迭代器失效
+ list
  + 链式结构,且为双向循环链表
  + 只有删除操作使得迭代器失效，扩容不会
### 指针与引用的联系与区别
+ 在C++底层中，引用是通过指针实现的
+ **指针可以为空，引用不能为空**, 引用必须初始化，且不能更改
+ 存在指针数组 ，不存在引用数组 
+ 不能返回对函数体内的局部对象的引用(会被析构)
  ```c++
  int* p[1] = {1}; // Yes
  int& q[1] = {a}; // No
  ```
### vector，deque与list区别
[list、vector和deque的区别](https://blog.csdn.net/gogokongyin/article/details/51178378)
  
1. c++多态的机制实现(虚函数表)
2. extern关键字
3. 一个数组传递到函数,蜕变成指针,求字节数
4.  定义在全局的对象,定义在堆中对象,定义在静态局部变量对象,定义在栈中的对象,析构函数的析构顺序(从函数汇编角度看待,非常容易这道题)
### new int[10]跟new int[10]()区别
    前者未初始化，后者初始化为0
6.  隔一个删除一个map中的元素(主要考察迭代器的失效问题) ， 虚函数如何实现的，画出内存图
7.  C 重载与重写的区别
8.  一串int型整数存放磁盘上的压缩存储方式，包括写入与读取及内存无法一次性读取时的解决办法
9.  零拷贝的了解
10. hash函数如何保证冲突最小
11. STL库的介绍（投C++的要对STL这块多上心）
12. vector使用的注意点及其原因， 频繁对vector调用push_back()对性能的影响和原因， vector重新分配内存的大小与方式
13. C++虚函数的具体实现原理
14. 析构函数一般写成虚函数的原因
15. 大数量整数的去重问题
16. 算法题：环形公路上加油站算法问题
17. 变长编码的实现与传输问题
18. 手写实现智能指针类
19. 布隆过滤器的特性及将其特性反转的实现（反转后即查到的一定存在，查不到的不一定不存在），Bloom过滤器的实现
20. STL底层的介绍
21. 网页解析的过程与实现方法
22. 网络层分片的原因与具体实现
23. 给定k个数组，每个数组都是有序的，且每个数组最大值-最小值<1000，1<k<1000，求所有数的中位数。回答思路
24. STL内存分配
25. C和C++的特点与区别
26. 快速排序的优化
27. 游戏中打怪时已经各个小怪的坐标，你放一个技能是圆形范围，快速求能打到的小怪（范围搜索问题，热门场景考察题）
28. 魔兽世界10人房间，现在组队规模有3人，有5人，如何让每个人等待的时间尽可能少，即将时间线上哪些队伍组合在一起开始一个游戏
29. 无锁编程解决单生产者多消费者问题和多生产者多消费者问题
30. 快速排序的稳定化算法
31. 传输报文中处理请求连接信息还有哪些信息
32. 如果让你设计微信视频，你会选择什么协议？如何实现
33. sizeof(A) sizeof(B) 如果B继承于A，二者大小关系如何
34. 基类的析构函数必须为虚函数吗？ 为什么?
35. strcpy strncopy 哪个更安全 实现strncpy
36. const关键字的作用 violate关键字作用
37. vector内存增长方式 vector list 区别 map 数据结构 红黑树与普通avl树的区别
38. time_wait 持续时间多长以及为什么
39. mmap
40. 写代码，去掉字符串中的空格空格，C语言实现
41. ２次握手超时数据包会影响很大，三次握手容易遭到syc攻击，四次挥手很多情况下是三次(tcpdump抓）以及常见的粘包，数据包安全．滑动窗口．巴拉巴拉
42. ｃ＋＋解决内存泄漏方法
43. 查内存泄露 valgrid
44. c++协程实现，异步编程，泛型编程，共享内存的内部锁
45. char *s1, const char *s2，删除s1中s2出现过的字符
46. C++ cout和printf有什么区别
47. 为什么模板类一般都是放在一个h文件中
48. 一副扑克牌，怎么实现随机打乱
49. 讲一讲C++中的static数据
50. 爬虫怎么防止爬到重复的网站
51. PCB
52. memcpy和memmove的区别
53. Linux虚拟地址空间
54. 缺页中断
55. 页表寻址
56. 如何修改句柄的最大值
57. future

### 常量指针和指针常量
```c++
#include <iostream>
using namespace std;
int main(){
    int a = 1,b = 2;
    const int * p; 
    p = &a;
    // *p = *p + 1;
    // 报read-only错误，p为常量指针，不能通过p来改变a的值(可以通过其他方式改变, 如下), 常量指针也可写为int const* p;
    a = 3;
    cout << (*p) << endl;
    int* const q = &a;
    // q为指针常量，q的地址不改变，内容可以改变, 即指针常量 = 常指针
    *q = *q + 1;
    // q = &b;
    // 报read-only错误，指针常量不能再次赋值
    cout << (*q) << endl;
    return 0;
}
```


### 什么是智能指针以及shared_ptr实现原理
参考[智能指针](https://www.cnblogs.com/wxquare/p/4759020.html)  
我们先看下列代码
```c++
Object* obj = new Object();
dosomething();
delete obj;
```
上述代码很容易理解，假如程序员忘记写```delete```语句或者```dosomething```时出现错误，则```obj```所指的对象便不会被安全删除，使用智能指针可以很大程度避免这个问题：智能指针是一个类，当智能指针超出类的作用域时，类会自动调用析构函数，析构函数就会自动释放资源。

智能指针在普通指针的基础上增加了对指针的引用计数，作为一个类，在栈上分配资源，离开作用域时析构
代码中有两点需要注意
+ 引用计数应该是一个指针```size_t *count```,而不是```size_t count```,因为假如以下语句   
```c++
SmartPointer<int> sp1(new int(5));
SmartPointer<int> sp2(sp1);
```
创建了两个对象，两个对象的引用计数```count```相同，但是当其中一个析构时，另一个对象的引用计数无法改变，离开作用域时便无法析构，所以这里使用指针，通过对同一地址的访问来判断

+ 赋值时如```sp1 = sp2```，需要判断```sp1```的引用计数，如果是最后一个持有者，应当释放资源，
