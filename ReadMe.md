> What You Must Know In C++

### C++程序内存分配

+ 栈：由编译器在需要的时候分配，在不需要的时候自动清楚的变量的存储区。里面的变量通常是局部变量,函数参数等,效率高但容量有限  
+ 堆：malloc/free，如果没有free，程序结束后，操作系统会自动回收  
+ 自由存储区：new/delete
+ 全局/静态存储区：全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，它们共同占用同一块内存区。
+ 常量存储区：这是一块比较特殊的存储区，他们里面存放的是常量
```c++
int a = 0; //全局初始化区
char *p1; //全局未初始化区
int main()
{
    int b; //栈
    char s[] = "abc"; //栈
    char *p2; //栈
    char *p3 = "123456"; //123456\0在常量区，p3在栈上
    static int c = 0; //全局（静态）初始化区
    p1 = (char *)malloc(10); //分配得来得10字节的区域在堆区
    p2 = (char *)malloc(20); //分配得来得20字节的区域在堆区
    strcpy(p1, "123456");
    //123456\0放在常量区，编译器可能会将它与p3所指向的"123456"优化成一块
    return 0;
}
```
自由存储区是c++概念，堆是操作系统概念，通常new是通过malloc实现的  
[C++ 自由存储区是否等价于堆](https://www.cnblogs.com/QG-whz/p/5060894.html)
### C++的static关键字的作用
+ 静态全局变量：在全局存储区分配内存，未经初始化会被自动初始化为0， 在声明它的文件中全局可见，在其他文件不可见
+ 静态局部变量：在全局存储区分配内存，在函数执行到该变量声明处的首次被初始化，之后不再初始化，如果没有初始化，自动初始化为0
+ 静态函数：静态函数不能被其他文件所用，只能在声明它的文件中可见
+ 静态成员：属于类的所有对象共享，存储在全局数据区，静态数据成员定义时要分配空间，所以不能在类声明中定义（静态常成员可以在类中定义）
**同全局变量相比，使用静态数据成员有两个优势：**
    - 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性 
    - 可以实现信息隐藏，静态数据成员可以是private成员，而全局变量不能
+ 静态成员函数：不与任何对象绑定，不包含this指针，在类的外部定义时不能使用static关键字，该关键字只出现在类内部声明语句中，静态成员函数不能够使用const修饰
### 宏，内联函数和普通函数区别
+ 宏：函数调用要有一定的时间和空间方面的开销，而宏只是在预处理的地方把代码展开，不需要额外的空间和时间方面的开销，所以调用宏比调用函数更有效率
    - 由预处理器对宏进行替代
    - 不能访问对象的私有成员
    - 定义很容易产生二义性
  ```c++
    #define MUL(x) (x) * (x)
    int a = 4;
    MUL(a++) // 20 
  ``` 
+ 内联函数：在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数  
  内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），内联函数在运行时可调试，而宏定义不可以  
  内联函数相比普通函数来说，取消了函数的参数压栈，减少了调用的开销  
  是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器，如果内联函数的函数体过大,一般的编译器会放弃内联方式,而采用普通方式调用函数   
  [虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联](https://www.yuque.com/huihut/interview/readme#ikirca)

### STL中迭代器失效
+ vector
  + 删除操作使得迭代器失效
  + push_back导致扩容使得迭代器失效
+ list
  + 链式结构,且为双向循环链表
  + 只有删除操作使得迭代器失效，扩容不会
### 指针与引用的联系与区别
+ C++中引用的本质是一个指针常量
+ **指针可以为空，引用不能为空**, 引用必须初始化，且不能更改
+ 存在指针数组 ，声明引用数组没有办法分配空间，不存在引用数组 
+ 不能返回对函数体内的局部对象的引用(会被析构)
  ```c++
  int* p[1] = {1}; // Yes
  int& q[1] = {a}; // No
  ```
### vector，deque与list区别
[list、vector和deque的区别](https://blog.csdn.net/gogokongyin/article/details/51178378)

### new int[10]跟new int[10]\(\)区别
    前者未初始化，后者初始化为0
6.  隔一个删除一个map中的元素(主要考察迭代器的失效问题) ， 虚函数如何实现的，画出内存图
### 重载重写重定义
+ 重载：函数名相同，函数参数个数，参数类型，参数顺序三者中有一个不同，发生在一个类内部
+ 重写：也叫作覆盖，子类中重新定义基类的相同名称和参数的虚函数，被重写的函数不能是static，访问修饰符也可以不同（private->public）
+ 重定义：也叫作隐藏，子类中重新定义基类中的非虚函数（参数可以不同），屏蔽了基类的同名函数
### 文件读写
+ read/write：需要将磁盘数据先拷贝到内核缓冲区，然后将内核缓冲区的数据拷贝到用户空间，发生两次拷贝
+ mmap：将磁盘数据拷贝到内核缓冲区，将OS缓冲区映射到用户空间，发生一次拷贝
    单个进行顺序访问文件时，使用read读文件时有read-ahead提前将数据缓存到文件缓冲区，因此mmap与read的性能不会差太多
    多个进程访问同一文件时，使用mmap可以完成文件共享，节省内存空间；随机访问文件时，cache命中率低，使用mmap通常更高效
+ 零拷贝：传统读写传输数据需要4次拷贝，2次上下文切换，使用sendfile可以绕过内核，仅进行三次拷贝
### 大数量整数的去重问题
+ 使用位图去重
+ 先hash分割文件保证小文件的独立性然后小文件内快排去重
### 布隆过滤器的特性及将其特性反转的实现（反转后即查到的一定存在，查不到的不一定不存在），Bloom过滤器的实现
    布隆过滤器先申请长度为N的空间，可以表示N个元素，存储x，使用k个hash函数得到k个地址，将k个地址置为1
    + 查询key，有一定概率key不在集合中也被查询为存在
    + 无法删除
### sizeof(A) sizeof(B) 如果B继承于A
+ 结构体的大小等于结构体内最大成员大小的整数倍
+ 结构体内的成员的首地址相对于结构体首地址的偏移量是其类型大小的整数倍，比如说double型成员相对于结构体的首地址的地址偏移量应该是8的倍数。
+ 为了满足规则1和2编译器会在结构体成员之后进行字节填充
+ 如果有虚函数，类会有虚函数指针（64位下8个字节）
```c++
// 64位系统
class A {};      // 1个字节
class B {char a;};// 1个字节
class C : public B{}; // 1个字节
class D { virtual void f(){}; char a;}; // 16个字节
class E : public D{}; // 16个字节
```
### 基类的析构函数必须为虚函数吗
实现多态时，为了防止只执行基类的析构函数而不析构子类，所以基类的析构函数可以不用是虚函数
### 常量指针和指针常量
```c++
#include <iostream>
using namespace std;
int main(){
    int a = 1,b = 2;
    const int * p; 
    p = &a;
    // *p = *p + 1;
    // 报read-only错误，p为常量指针，不能通过p来改变a的值(可以通过其他方式改变, 如下), 常量指针也可写为int const* p;
    a = 3;
    cout << (*p) << endl;
    int* const q = &a;
    // q为指针常量，q的地址不改变，内容可以改变, 即指针常量 = 常指针
    *q = *q + 1;
    // q = &b;
    // 报read-only错误，指针常量不能再次赋值
    cout << (*q) << endl;
    return 0;
}
```
### 什么是智能指针以及shared_ptr实现原理
参考[智能指针](https://www.cnblogs.com/wxquare/p/4759020.html)  
我们先看下列代码
```c++
Object* obj = new Object();
dosomething();
delete obj;
```
上述代码很容易理解，假如程序员忘记写```delete```语句或者```dosomething```时出现错误，则```obj```所指的对象便不会被安全删除，使用智能指针可以很大程度避免这个问题：智能指针是一个类，当智能指针超出类的作用域时，类会自动调用析构函数，析构函数就会自动释放资源。

智能指针在普通指针的基础上增加了对指针的引用计数，作为一个类，在栈上分配资源，离开作用域时析构
代码中有两点需要注意
+ 引用计数应该是一个指针```size_t *count```,而不是```size_t count```,因为假如以下语句   
```c++
SmartPointer<int> sp1(new int(5));
SmartPointer<int> sp2(sp1);
```
创建了两个对象，两个对象的引用计数```count```相同，但是当其中一个析构时，另一个对象的引用计数无法改变，离开作用域时便无法析构，所以这里使用指针，通过对同一地址的访问来判断

+ 赋值时如```sp1 = sp2```，需要判断```sp1```的引用计数，如果是最后一个持有者，应当释放资源，

### 使用智能指针解决循环引用的问题
```c++
#include <iostream>
#include <memory>
using namespace std;

class B;
class A {
    public:
    shared_ptr<B> pb; //weak_ptr<B> pb;
    ~A(){ cout << "A is deconstructed" << endl;}
};

class B{
    public:
    shared_ptr<A> pa; //weak_ptr<A> pa;
    ~B(){ cout << "B is deconstructed" << endl;}
};

int main() {
    shared_ptr<A> a = make_shared<A>();
    shared_ptr<B> b = make_shared<B>();
    a->pb = b;
    b->pa = a;
    
    cout << a.use_count() << " - " << b.use_count() << endl;
    return 0;
}
```

使用shared_ptr打印
```
2 - 2
```
使用weak_ptr打印
```
1 - 1
B is deconstructed
A is deconstructed
```
weak_ptr不改变引用计数
